import type { Context } from '../../../context.js'
import { Composer, InlineKeyboard } from 'grammy'
import { Database } from '../../../../modules/database/index.js'
import { EmploymentStatus } from '../../../../../generated/prisma/index.js'
import { createSimpleDatePicker, parseDateFromCallback } from '../../../../modules/ui/calendar.js'

export const employeeStatusSimpleHandler = new Composer<Context>()

// ÿØÿßŸÑÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇŸàŸäŸÖ ŸÖÿ®ÿ≥ÿ∑ - ÿ™ŸÖ ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑŸáÿß ÿ®ÿßŸÑÿ™ŸÇŸàŸäŸÖ ÿßŸÑÿπÿßŸÖ
function createSimpleCalendar(employeeId: number): InlineKeyboard {
  return createSimpleDatePicker(
    `hr:employee:status:simple:date:${employeeId}`,
    `hr:employee:edit:${employeeId}`
  )
}

// ŸÖÿπÿßŸÑÿ¨ ÿ™ÿ∫ŸäŸäÿ± ÿ≠ÿßŸÑÿ© ÿßŸÑÿπÿßŸÖŸÑ ÿßŸÑŸÖÿ®ÿ≥ÿ∑
employeeStatusSimpleHandler.callbackQuery(/^hr:employee:status:simple:(\d+)$/, async (ctx) => {
  await ctx.answerCallbackQuery()
  
  const employeeId = parseInt(ctx.match[1])
  
  try {
    const prisma = Database.prisma
    const employee = await prisma.employee.findUnique({
      where: { id: employeeId },
      include: { position: true, department: true }
    })
    
    if (!employee) {
      await ctx.editMessageText('‚ùå ÿßŸÑÿπÿßŸÖŸÑ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.')
      return
    }

    // ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿπÿßŸÖŸÑ
    const isCurrentEmployee = employee.isActive && 
                             employee.employmentStatus === EmploymentStatus.ACTIVE && 
                             !employee.resignationDate && 
                             !employee.terminationDate

    let message = `üìä ÿ™ÿ∫ŸäŸäÿ± ÿ≠ÿßŸÑÿ© ÿßŸÑÿπÿßŸÖŸÑ\n\n`
    message += `üë§ ÿßŸÑÿπÿßŸÖŸÑ: ${employee.fullName}\n`
    message += `üÜî ÿßŸÑŸÉŸàÿØ: ${employee.employeeCode}\n`
    message += `üìã ÿßŸÑŸàÿ∏ŸäŸÅÿ©: ${employee.position?.titleAr || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}\n\n`
    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`

    if (isCurrentEmployee) {
      message += `üë∑ ÿßŸÑÿπÿßŸÖŸÑ ÿ≠ÿßŸÑŸäÿßŸã: ÿπÿßŸÖŸÑ ÿ≠ÿßŸÑŸâ\n\n`
      message += `ÿßÿÆÿ™ÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©:`
      
      const keyboard = new InlineKeyboard()
        .text('üè¢ ŸÅŸä ÿßŸÑÿπŸÖŸÑ', `hr:employee:status:change:${employeeId}:WORKING`)
        .text('üèñÔ∏è ŸÅŸä ÿ•ÿ¨ÿßÿ≤ÿ©', `hr:employee:status:change:${employeeId}:ON_LEAVE`).row()
        .text('‚úàÔ∏è ŸÅŸä ŸÖÿ£ŸÖŸàÿ±Ÿäÿ©', `hr:employee:status:change:${employeeId}:ON_MISSION`).row()
        .text('üìÇ ÿ™ÿ≠ŸàŸäŸÑ ŸÑÿπÿßŸÖŸÑ ÿ≥ÿßÿ®ŸÇ', `hr:employee:status:change:${employeeId}:FORMER`).row()
        .text('‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ', `hr:employee:edit:${employeeId}`)
      
      await ctx.editMessageText(message, { reply_markup: keyboard })
    } else {
      message += `üìÇ ÿßŸÑÿπÿßŸÖŸÑ ÿ≠ÿßŸÑŸäÿßŸã: ÿπÿßŸÖŸÑ ÿ≥ÿßÿ®ŸÇ\n\n`
      message += `ÿßÿÆÿ™ÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©:`
      
      const keyboard = new InlineKeyboard()
        .text('üë∑ ÿ•ÿπÿßÿØÿ© ÿ™ŸÅÿπŸäŸÑ', `hr:employee:status:change:${employeeId}:REACTIVATE`)
        .text('üìã ÿ™ÿµŸÅŸäÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®', `hr:employee:status:change:${employeeId}:SETTLED`).row()
        .text('‚è∏Ô∏è ÿ™ÿπŸÑŸäŸÇ ÿßŸÑÿ≠ÿ≥ÿßÿ®', `hr:employee:status:change:${employeeId}:SUSPENDED`).row()
        .text('‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ', `hr:employee:edit:${employeeId}`)
      
      await ctx.editMessageText(message, { reply_markup: keyboard })
    }

  } catch (error) {
    console.error('Error loading employee status:', error)
    await ctx.editMessageText('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπÿßŸÖŸÑ.')
  }
})

// ŸÖÿπÿßŸÑÿ¨ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑŸÅÿπŸÑŸä
employeeStatusSimpleHandler.callbackQuery(/^hr:employee:status:change:(\d+):(.+)$/, async (ctx) => {
  await ctx.answerCallbackQuery()
  
  const employeeId = parseInt(ctx.match[1])
  const newStatus = ctx.match[2]
  
  try {
    const prisma = Database.prisma
    const employee = await prisma.employee.findUnique({
      where: { id: employeeId }
    })
    
    if (!employee) {
      await ctx.editMessageText('‚ùå ÿßŸÑÿπÿßŸÖŸÑ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.')
      return
    }

    // ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
    const currentStatus = employee.isActive && 
                        employee.employmentStatus === EmploymentStatus.ACTIVE && 
                        !employee.resignationDate && 
                        !employee.terminationDate ? 'CURRENT' : 'FORMER'

    // ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ© ŸàÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©
    let updateData: any = {}
    let statusLabel = ''
    let requiresDate = false
    let dateField = ''

    switch (newStatus) {
      case 'WORKING':
        updateData = {
          isActive: true,
          employmentStatus: EmploymentStatus.ACTIVE,
          resignationDate: null,
          terminationDate: null
        }
        statusLabel = 'ŸÅŸä ÿßŸÑÿπŸÖŸÑ'
        break
        
      case 'ON_LEAVE':
        updateData = {
          isActive: true,
          employmentStatus: EmploymentStatus.ON_LEAVE
        }
        statusLabel = 'ŸÅŸä ÿ•ÿ¨ÿßÿ≤ÿ©'
        break
        
      case 'ON_MISSION':
        updateData = {
          isActive: true,
          employmentStatus: EmploymentStatus.ON_MISSION
        }
        statusLabel = 'ŸÅŸä ŸÖÿ£ŸÖŸàÿ±Ÿäÿ©'
        break
        
      case 'FORMER':
        // ÿ≥Ÿäÿ∑ŸÑÿ® ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©
        const keyboard = new InlineKeyboard()
          .text('üìù ÿßÿ≥ÿ™ŸÇÿßŸÑ', `hr:employee:status:former:${employeeId}:RESIGNED`)
          .text('üö´ ŸÅÿµŸÑ', `hr:employee:status:former:${employeeId}:TERMINATED`).row()
          .text('üë¥ ÿ™ŸÇÿßÿπÿØ', `hr:employee:status:former:${employeeId}:RETIRED`).row()
          .text('‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ', `hr:employee:status:simple:${employeeId}`)
        
        await ctx.editMessageText(
          `üìÇ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿπÿßŸÖŸÑ ÿ•ŸÑŸâ ÿπÿßŸÖŸÑ ÿ≥ÿßÿ®ŸÇ\n\n` +
          `üë§ ÿßŸÑÿπÿßŸÖŸÑ: ${employee.fullName}\n\n` +
          `ÿßÿÆÿ™ÿ± ÿ≥ÿ®ÿ® ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿπŸÖŸÑ:`,
          { reply_markup: keyboard }
        )
        return
        
      case 'REACTIVATE':
        updateData = {
          isActive: true,
          employmentStatus: EmploymentStatus.ACTIVE,
          resignationDate: null,
          terminationDate: null
        }
        statusLabel = 'ÿ•ÿπÿßÿØÿ© ÿ™ŸÅÿπŸäŸÑ'
        break
        
      case 'SETTLED':
        updateData = {
          employmentStatus: EmploymentStatus.SETTLED
        }
        statusLabel = 'ÿ™ŸÖ ÿ™ÿµŸÅŸäÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®'
        break
        
      case 'SUSPENDED':
        updateData = {
          employmentStatus: EmploymentStatus.SUSPENDED
        }
        statusLabel = 'ÿ≠ÿ≥ÿßÿ® ŸÖÿπŸÑŸÇ'
        break
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    await prisma.employee.update({
      where: { id: employeeId },
      data: updateData
    })

    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ∞Ÿä ŸÇÿßŸÖ ÿ®ÿßŸÑÿ™ÿ∫ŸäŸäÿ±
    const adminUser = ctx.from ? await prisma.user.findUnique({ where: { telegramId: BigInt(ctx.from.id) } }) : null

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑÿ≥ÿ¨ŸÑ
    await prisma.auditLog.create({
      data: {
        model: 'Employee',
        recordId: employeeId.toString(),
        action: 'UPDATE',
        category: 'HR',
        fieldName: 'employmentStatus',
        oldValue: currentStatus,
        newValue: statusLabel,
        changedByUserId: adminUser?.id,
        description: `ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿ•ŸÑŸâ: ${statusLabel}`,
        metadata: {
          statusDate: new Date()
        }
      }
    })

    const keyboard = new InlineKeyboard()
      .text('‚úèÔ∏è ÿ™ÿπÿØŸäŸÑ ÿ≠ŸÇŸÑ ÿ¢ÿÆÿ±', `hr:employee:edit:${employeeId}`)
      .text('üìÑ ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ', `hr:employee:details:${employeeId}`)

    await ctx.editMessageText(
      `‚úÖ ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\n` +
      `üìä ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©: ${statusLabel}\n` +
      `üìÖ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ: ${new Date().toLocaleDateString('ar-EG')}`,
      { reply_markup: keyboard }
    )

  } catch (error) {
    console.error('Error updating employee status:', error)
    await ctx.editMessageText('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≠ÿßŸÑÿ©.')
  }
})

// ŸÖÿπÿßŸÑÿ¨ ÿßÿÆÿ™Ÿäÿßÿ± ÿ≥ÿ®ÿ® ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿπŸÖŸÑ ŸÑŸÑÿπÿßŸÖŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ
employeeStatusSimpleHandler.callbackQuery(/^hr:employee:status:former:(\d+):(.+)$/, async (ctx) => {
  await ctx.answerCallbackQuery()
  
  const employeeId = parseInt(ctx.match[1])
  const terminationType = ctx.match[2] as EmploymentStatus
  
  const statusLabels: { [key in EmploymentStatus]?: string } = {
    [EmploymentStatus.RESIGNED]: 'ÿßÿ≥ÿ™ŸÇÿßŸÑ',
    [EmploymentStatus.TERMINATED]: 'ŸÅÿµŸÑ',
    [EmploymentStatus.RETIRED]: 'ÿ™ŸÇÿßÿπÿØ'
  }
  
  const dateFields: { [key in EmploymentStatus]?: string } = {
    [EmploymentStatus.RESIGNED]: 'resignationDate',
    [EmploymentStatus.TERMINATED]: 'terminationDate',
    [EmploymentStatus.RETIRED]: 'terminationDate' // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ terminationDate ŸÑŸÑÿ™ŸÇÿßÿπÿØ ÿ£Ÿäÿ∂ÿßŸã
  }

  // ÿ≠ŸÅÿ∏ ŸÜŸàÿπ ÿßŸÑÿ•ŸÜŸáÿßÿ° ŸÅŸä ÿßŸÑÿ¨ŸÑÿ≥ÿ©
  ctx.session = ctx.session || {}
  ctx.session.statusChangeEdit = {
    employeeId,
    newStatus: terminationType,
    step: 'awaiting_date_selection',
    dateField: dateFields[terminationType] as any,
    dateType: 'custom'
  }

  const keyboard = new InlineKeyboard()
    .text('üìÖ ÿßŸÑŸäŸàŸÖ', `hr:employee:status:simple:date:${employeeId}:today`)
    .text('üìÜ ÿ™ÿßÿ±ŸäÿÆ ÿ¢ÿÆÿ±', `hr:employee:status:simple:date:${employeeId}:custom`).row()
    .text('‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ', `hr:employee:status:simple:${employeeId}`)

  await ctx.editMessageText(
    `üìÖ ÿ™ÿ≠ÿØŸäÿØ ÿ™ÿßÿ±ŸäÿÆ ${statusLabels[terminationType]}\n\n` +
    `ÿßÿÆÿ™ÿ± ÿßŸÑÿ™ÿßÿ±ŸäÿÆ:`,
    { reply_markup: keyboard }
  )
})

// ŸÖÿπÿßŸÑÿ¨ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
employeeStatusSimpleHandler.callbackQuery(/^hr:employee:status:simple:date:(\d+):(.+)$/, async (ctx) => {
  await ctx.answerCallbackQuery()
  
  const employeeId = parseInt(ctx.match[1])
  const dateType = ctx.match[2]
  
  if (!ctx.session?.statusChangeEdit) {
    await ctx.editMessageText(
      '‚ùå ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿπŸÖŸÑŸäÿ©.',
      { reply_markup: new InlineKeyboard().text('‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ', `hr:employee:status:simple:${employeeId}`) }
    )
    return
  }

  const { newStatus, dateField } = ctx.session.statusChangeEdit

  try {
    let selectedDate: Date | null = null
    
    if (dateType === 'today') {
      selectedDate = new Date()
    } else if (dateType === 'custom') {
      // ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿÆÿ∑Ÿàÿ© ŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
      ctx.session.statusChangeEdit.step = 'awaiting_date_input'
      
      const statusLabels: { [key: string]: string } = {
        'RESIGNED': 'ÿßÿ≥ÿ™ŸÇÿßŸÑ',
        'TERMINATED': 'ŸÅÿµŸÑ',
        'RETIRED': 'ÿ™ŸÇÿßÿπÿØ'
      }
      
      // ÿπÿ±ÿ∂ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸäÿØŸàŸäÿßŸã ÿ£Ÿà ÿßÿÆÿ™Ÿäÿßÿ±Ÿá ŸÖŸÜ ÿßŸÑÿ™ŸÇŸàŸäŸÖ
      await ctx.editMessageText(
        `üìÖ ÿ£ÿØÿÆŸÑ ÿ™ÿßÿ±ŸäÿÆ ${statusLabels[newStatus]}\n\n` +
        `üí° ŸäŸÖŸÉŸÜŸÉ:\n` +
        `‚Ä¢ ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸäÿØŸàŸäÿßŸã ÿ®ÿµŸäÿ∫ÿ© DD/MM/YYYY (ŸÖÿ´ÿßŸÑ: 15/12/2024)\n` +
        `‚Ä¢ ÿ£Ÿà ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ÿßŸÑÿ™ŸÇŸàŸäŸÖ ÿ£ÿØŸÜÿßŸá:`,
        { reply_markup: createSimpleCalendar(employeeId) }
      )
      return
    } else {
      // ÿ™ÿßÿ±ŸäÿÆ ŸÖŸÜ ÿßŸÑÿ™ŸÇŸàŸäŸÖ ÿßŸÑÿ¨ÿØŸäÿØ
      selectedDate = parseDateFromCallback(dateType)
      
      if (!selectedDate) {
        throw new Error('ÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠')
      }
    }

    const prisma = Database.prisma
    const adminUser = ctx.from ? await prisma.user.findUnique({ where: { telegramId: BigInt(ctx.from.id) } }) : null
    
    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≠ÿßŸÑÿ© ŸàÿßŸÑÿ™ÿßÿ±ŸäÿÆ
    const updateData: any = {
      isActive: false,
      employmentStatus: newStatus,
      [dateField]: selectedDate
    }

    await prisma.employee.update({
      where: { id: employeeId },
      data: updateData
    })

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑÿ≥ÿ¨ŸÑ
    await prisma.auditLog.create({
      data: {
        model: 'Employee',
        recordId: employeeId.toString(),
        action: 'UPDATE',
        category: 'HR',
        fieldName: 'employmentStatus',
        oldValue: 'CURRENT',
        newValue: newStatus,
        changedByUserId: adminUser?.id,
        description: `ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿπŸÖŸÑ: ${newStatus}`,
        metadata: {
          statusDate: selectedDate
        }
      }
    })

    // ŸÖÿ≥ÿ≠ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ
    delete ctx.session.statusChangeEdit

    const statusLabels: { [key: string]: string } = {
      'RESIGNED': 'ÿßÿ≥ÿ™ŸÇÿßŸÑ',
      'TERMINATED': 'ŸÅÿµŸÑ',
      'RETIRED': 'ÿ™ŸÇÿßÿπÿØ'
    }

    const keyboard = new InlineKeyboard()
      .text('‚úèÔ∏è ÿ™ÿπÿØŸäŸÑ ÿ≠ŸÇŸÑ ÿ¢ÿÆÿ±', `hr:employee:edit:${employeeId}`)
      .text('üìÑ ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ', `hr:employee:details:${employeeId}`)

    await ctx.editMessageText(
      `‚úÖ ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\n` +
      `üìä ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©: ${statusLabels[newStatus]}\n` +
      `üìÖ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ: ${selectedDate.toLocaleDateString('ar-EG')}`,
      { reply_markup: keyboard }
    )

  } catch (error) {
    console.error('Error updating employee status:', error)
    
    const keyboard = new InlineKeyboard()
      .text('‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ', `hr:employee:status:simple:${employeeId}`)
    
    await ctx.editMessageText(
      '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≠ÿßŸÑÿ©.\n\n' +
      `ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿ∑ÿ£: ${error instanceof Error ? error.message : 'ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ'}`,
      { reply_markup: keyboard }
    )
    
    // ÿπÿØŸÖ ŸÖÿ≥ÿ≠ ÿßŸÑÿ≠ÿßŸÑÿ© ŸÑŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©
  }
})

// ŸÖÿπÿßŸÑÿ¨ ÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ÿßŸÑŸÜÿµŸàÿµ ŸÑÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÖÿÆÿµÿµ
employeeStatusSimpleHandler.on('message:text', async (ctx) => {
  // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ≠ÿßŸÑÿ© ÿ™ÿπÿØŸäŸÑ ÿ≠ÿßŸÑÿ© ŸÜÿ¥ÿ∑ÿ© ÿ™ŸÜÿ™ÿ∏ÿ± ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
  if (!ctx.session?.statusChangeEdit || ctx.session.statusChangeEdit.step !== 'awaiting_date_input') {
    return // ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸáŸÜÿßŸÉ ÿ≠ÿßŸÑÿ© ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ•ÿØÿÆÿßŸÑ ÿ™ÿßÿ±ŸäÿÆ
  }

  const { employeeId, newStatus, dateField } = ctx.session.statusChangeEdit
  const dateText = ctx.message.text.trim()

  try {
    // ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÖŸÜ ÿßŸÑÿµŸäÿ∫ ÿßŸÑŸÖÿÆÿ™ŸÑŸÅÿ©
    let parsedDate: Date | null = null
    
    // ÿµŸäÿ∫ÿ© DD/MM/YYYY ÿ£Ÿà DD-MM-YYYY
    const dateRegex = /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/
    const match = dateText.match(dateRegex)
    
    if (match) {
      const day = parseInt(match[1])
      const month = parseInt(match[2]) - 1 // ÿßŸÑÿ¥Ÿáÿ± Ÿäÿ®ÿØÿ£ ŸÖŸÜ 0 ŸÅŸä JavaScript
      const year = parseInt(match[3])
      
      parsedDate = new Date(year, month, day)
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
      if (parsedDate.getDate() !== day || parsedDate.getMonth() !== month || parsedDate.getFullYear() !== year) {
        throw new Error('ÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠')
      }
    } else {
      throw new Error('ÿµŸäÿ∫ÿ© ÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©')
    }

    if (!parsedDate) {
      throw new Error('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ®ŸÜÿ¨ÿßÿ≠')
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÑŸäÿ≥ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ÿßŸÑÿ®ÿπŸäÿØ
    const today = new Date()
    const maxDate = new Date(today.getFullYear() + 1, today.getMonth(), today.getDate())
    
    if (parsedDate > maxDate) {
      await ctx.reply('‚ùå ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÑÿß ŸäŸÖŸÉŸÜ ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ÿßŸÑÿ®ÿπŸäÿØ.')
      return
    }

    const prisma = Database.prisma
    const adminUser = ctx.from ? await prisma.user.findUnique({ where: { telegramId: BigInt(ctx.from.id) } }) : null
    
    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≠ÿßŸÑÿ© ŸàÿßŸÑÿ™ÿßÿ±ŸäÿÆ
    const updateData: any = {
      isActive: false,
      employmentStatus: newStatus,
      [dateField]: parsedDate
    }

    await prisma.employee.update({
      where: { id: employeeId },
      data: updateData
    })

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑÿ≥ÿ¨ŸÑ
    await prisma.auditLog.create({
      data: {
        model: 'Employee',
        recordId: employeeId.toString(),
        action: 'UPDATE',
        category: 'HR',
        fieldName: 'employmentStatus',
        oldValue: 'CURRENT',
        newValue: newStatus,
        changedByUserId: adminUser?.id,
        description: `ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿπŸÖŸÑ: ${newStatus}`,
        metadata: {
          statusDate: parsedDate
        }
      }
    })

    // ŸÖÿ≥ÿ≠ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ
    delete ctx.session.statusChangeEdit

    const statusLabels: { [key: string]: string } = {
      'RESIGNED': 'ÿßÿ≥ÿ™ŸÇÿßŸÑ',
      'TERMINATED': 'ŸÅÿµŸÑ',
      'RETIRED': 'ÿ™ŸÇÿßÿπÿØ'
    }

    const keyboard = new InlineKeyboard()
      .text('‚úèÔ∏è ÿ™ÿπÿØŸäŸÑ ÿ≠ŸÇŸÑ ÿ¢ÿÆÿ±', `hr:employee:edit:${employeeId}`)
      .text('üìÑ ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ', `hr:employee:details:${employeeId}`)

    await ctx.reply(
      `‚úÖ ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\n` +
      `üìä ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©: ${statusLabels[newStatus]}\n` +
      `üìÖ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ: ${parsedDate.toLocaleDateString('ar-EG')}`,
      { reply_markup: keyboard }
    )

  } catch (error) {
    console.error('Error parsing date:', error)
    
    const keyboard = new InlineKeyboard()
      .text('‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ', `hr:employee:status:simple:${employeeId}`)
    
    await ctx.reply(
      '‚ùå ÿµŸäÿ∫ÿ© ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©.\n\n' +
      'üí° Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ®ÿµŸäÿ∫ÿ©:\n' +
      '‚Ä¢ DD/MM/YYYY (ŸÖÿ´ÿßŸÑ: 15/12/2024)\n' +
      '‚Ä¢ DD-MM-YYYY (ŸÖÿ´ÿßŸÑ: 15-12-2024)\n\n' +
      'ÿ£Ÿà ÿßÿ∂ÿ∫ÿ∑ "ÿ±ÿ¨Ÿàÿπ" ŸàÿßÿÆÿ™ÿ± ŸÖŸÜ ÿßŸÑÿ™ŸÇŸàŸäŸÖ.',
      { reply_markup: keyboard }
    )
  }
})
