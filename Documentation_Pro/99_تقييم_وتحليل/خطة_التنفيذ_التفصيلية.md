# ğŸ› ï¸ Ø®Ø·Ø© Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ© - ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¨ÙˆØª

## ğŸ“‹ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª
1. [Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ§Øª Ø§Ù„Ø­Ø±Ø¬Ø©](#Ø§Ù„Ù…Ø±Ø­Ù„Ø©-Ø§Ù„Ø£ÙˆÙ„Ù‰)
2. [Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¬ÙˆØ¯Ø©](#Ø§Ù„Ù…Ø±Ø­Ù„Ø©-Ø§Ù„Ø«Ø§Ù†ÙŠØ©)
3. [Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©: Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ÙˆØ§Ù„Ø£Ø¯Ø§Ø¡](#Ø§Ù„Ù…Ø±Ø­Ù„Ø©-Ø§Ù„Ø«Ø§Ù„Ø«Ø©)
4. [Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©: Dashboard](#Ø§Ù„Ù…Ø±Ø­Ù„Ø©-Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©)
5. [Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©: Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©](#Ø§Ù„Ù…Ø±Ø­Ù„Ø©-Ø§Ù„Ø®Ø§Ù…Ø³Ø©)
6. [Checklists ÙˆØ§Ù„ØªØ­Ù‚Ù‚](#checklists)

---

## ğŸ”´ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ§Øª Ø§Ù„Ø­Ø±Ø¬Ø© (4 Ø£Ø³Ø§Ø¨ÙŠØ¹)

### Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 1: ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©

#### 1.1 Ø¥Ø¶Ø§ÙØ© Rate Limiting Middleware
```typescript
// src/bot/middlewares/rate-limiter.ts
import { Middleware } from 'grammy'
import { createClient } from 'redis'

interface RateLimitOptions {
  windowMs: number // Ù†Ø§ÙØ°Ø© Ø§Ù„ÙˆÙ‚Øª Ø¨Ø§Ù„Ù…ÙŠÙ„ÙŠ Ø«Ø§Ù†ÙŠØ©
  maxRequests: number // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø·Ù„Ø¨Ø§Øª
}

export function createRateLimiter(options: RateLimitOptions): Middleware {
  const redis = createClient({
    url: process.env.REDIS_URL
  })

  return async (ctx, next) => {
    const userId = ctx.from?.id
    if (!userId)
      return next()

    const key = `rate_limit:${userId}`
    const requests = await redis.incr(key)

    if (requests === 1) {
      await redis.expire(key, options.windowMs / 1000)
    }

    if (requests > options.maxRequests) {
      return ctx.reply('âš ï¸ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±.')
    }

    return next()
  }
}

// Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ index.ts
bot.use(createRateLimiter({
  windowMs: 60000, // Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©
  maxRequests: 20 // 20 Ø·Ù„Ø¨ ÙÙŠ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©
}))
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 2-3 Ø£ÙŠØ§Ù…
**Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:** ğŸ”´ Ø­Ø±Ø¬Ø©

#### 1.2 Ø¥Ø¶Ø§ÙØ© Data Encryption
```typescript
// src/modules/security/encryption.ts
import crypto from 'crypto'

const ALGORITHM = 'aes-256-gcm'
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY // 32 bytes
const IV_LENGTH = 16

export class EncryptionService {
  static encrypt(text: string): string {
    const iv = crypto.randomBytes(IV_LENGTH)
    const cipher = crypto.createCipheriv(
      ALGORITHM,
      Buffer.from(ENCRYPTION_KEY, 'hex'),
      iv
    )

    let encrypted = cipher.update(text, 'utf8', 'hex')
    encrypted += cipher.final('hex')

    const authTag = cipher.getAuthTag()

    return `${iv.toString('hex')}:${encrypted}:${authTag.toString('hex')}`
  }

  static decrypt(encryptedText: string): string {
    const [ivHex, encrypted, authTagHex] = encryptedText.split(':')

    const decipher = crypto.createDecipheriv(
      ALGORITHM,
      Buffer.from(ENCRYPTION_KEY, 'hex'),
      Buffer.from(ivHex, 'hex')
    )

    decipher.setAuthTag(Buffer.from(authTagHex, 'hex'))

    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')

    return decrypted
  }
}

// ØªØ·Ø¨ÙŠÙ‚ ÙÙŠ Prisma Model
// prisma/schema.prisma
model User {
  // ...
  phone     String? // Ø³ÙŠØªÙ… ØªØ´ÙÙŠØ±Ù‡
  email     String? // Ø³ÙŠØªÙ… ØªØ´ÙÙŠØ±Ù‡
  // ...
}

// Middleware Ù„Ù„ØªØ´ÙÙŠØ± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
// src/modules/database/middlewares/encryption.middleware.ts
prisma.$use(async (params, next) => {
  // Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸ - ØªØ´ÙÙŠØ±
  if (params.action === 'create' || params.action === 'update') {
    if (params.args.data.phone) {
      params.args.data.phone = EncryptionService.encrypt(params.args.data.phone)
    }
    if (params.args.data.email) {
      params.args.data.email = EncryptionService.encrypt(params.args.data.email)
    }
  }

  const result = await next(params)

  // Ø¨Ø¹Ø¯ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© - ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
  if (params.action === 'findUnique' || params.action === 'findFirst' || params.action === 'findMany') {
    if (result) {
      if (Array.isArray(result)) {
        result.forEach(item => {
          if (item.phone) item.phone = EncryptionService.decrypt(item.phone)
          if (item.email) item.email = EncryptionService.decrypt(item.email)
        })
      } else {
        if (result.phone) result.phone = EncryptionService.decrypt(result.phone)
        if (result.email) result.email = EncryptionService.decrypt(result.email)
      }
    }
  }

  return result
})
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 3-4 Ø£ÙŠØ§Ù…
**Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:** ğŸ”´ Ø­Ø±Ø¬Ø©

#### 1.3 Ø¥Ø¶Ø§ÙØ© Session Management
```typescript
import { randomBytes } from 'node:crypto'
// src/modules/security/session-manager.ts
import { createClient } from 'redis'

interface Session {
  userId: number
  telegramId: bigint
  createdAt: Date
  lastActivity: Date
  ipAddress?: string
  userAgent?: string
}

export class SessionManager {
  private redis = createClient({ url: process.env.REDIS_URL })
  private SESSION_TTL = 24 * 60 * 60 // 24 Ø³Ø§Ø¹Ø©

  async createSession(userId: number, telegramId: bigint, metadata?: any): Promise<string> {
    const sessionId = randomBytes(32).toString('hex')

    const session: Session = {
      userId,
      telegramId,
      createdAt: new Date(),
      lastActivity: new Date(),
      ...metadata
    }

    await this.redis.setEx(
      `session:${sessionId}`,
      this.SESSION_TTL,
      JSON.stringify(session)
    )

    // Ø­ÙØ¸ Ø¬Ù…ÙŠØ¹ Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    await this.redis.sAdd(`user:${userId}:sessions`, sessionId)

    return sessionId
  }

  async getSession(sessionId: string): Promise<Session | null> {
    const data = await this.redis.get(`session:${sessionId}`)
    return data ? JSON.parse(data) : null
  }

  async updateActivity(sessionId: string): Promise<void> {
    const session = await this.getSession(sessionId)
    if (session) {
      session.lastActivity = new Date()
      await this.redis.setEx(
        `session:${sessionId}`,
        this.SESSION_TTL,
        JSON.stringify(session)
      )
    }
  }

  async deleteSession(sessionId: string): Promise<void> {
    const session = await this.getSession(sessionId)
    if (session) {
      await this.redis.del(`session:${sessionId}`)
      await this.redis.sRem(`user:${session.userId}:sessions`, sessionId)
    }
  }

  async getUserSessions(userId: number): Promise<Session[]> {
    const sessionIds = await this.redis.sMembers(`user:${userId}:sessions`)
    const sessions: Session[] = []

    for (const sessionId of sessionIds) {
      const session = await this.getSession(sessionId)
      if (session)
        sessions.push(session)
    }

    return sessions
  }

  async deleteAllUserSessions(userId: number): Promise<void> {
    const sessions = await this.getUserSessions(userId)
    for (const session of sessions) {
      const sessionId = await this.findSessionId(session)
      if (sessionId)
        await this.deleteSession(sessionId)
    }
  }
}
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 2-3 Ø£ÙŠØ§Ù…
**Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:** ğŸ”´ Ø­Ø±Ø¬Ø©

---

### Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 2: Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ PostgreSQL

#### 2.1 Ø¥Ø¹Ø¯Ø§Ø¯ PostgreSQL
```bash
# ØªØ«Ø¨ÙŠØª PostgreSQL
# Ø¹Ù„Ù‰ Ubuntu:
sudo apt-get install postgresql postgresql-contrib

# Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª
sudo -u postgres psql
CREATE DATABASE telegram_bot;
CREATE USER bot_user WITH ENCRYPTED PASSWORD 'your_password';
GRANT ALL PRIVILEGES ON DATABASE telegram_bot TO bot_user;
```

#### 2.2 ØªØ­Ø¯ÙŠØ« Prisma Schema
```prisma
// prisma/schema.prisma
datasource db {
  provider = "postgresql" // ØªØºÙŠÙŠØ± Ù…Ù† sqlite
  url      = env("DATABASE_URL")
}

// Ø¥Ø¶Ø§ÙØ© Ù…ÙŠØ²Ø§Øª PostgreSQL Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
model User {
  // ... Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©

  @@index([telegramId], type: Hash) // Hash Index Ù„Ù„Ø¨Ø­Ø« Ø§Ù„Ø³Ø±ÙŠØ¹
  @@index([createdAt], type: BTree) // BTree Ù„Ù„ØªØ±ØªÙŠØ¨

  // Full-Text Search
  @@index([fullName], type: Gin, ops: [raw("gin_trgm_ops")])
}

// Ø¥Ø¶Ø§ÙØ© Extensions
generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
  previewFeatures = ["fullTextSearch"]
}
```

#### 2.3 Migration Script
```typescript
import { PrismaClient as PostgresPrisma } from '../generated/prisma'
// scripts/migrate-to-postgres.ts
import { PrismaClient as SqlitePrisma } from '../generated/prisma-sqlite'

async function migrate() {
  const sqliteDB = new SqlitePrisma()
  const postgresDB = new PostgresPrisma()

  console.log('ğŸ”„ Ø¨Ø¯Ø¡ Ù†Ù‚Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...')

  // Ù†Ù‚Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  const users = await sqliteDB.user.findMany()
  console.log(`ğŸ“¤ Ù†Ù‚Ù„ ${users.length} Ù…Ø³ØªØ®Ø¯Ù…...`)

  for (const user of users) {
    await postgresDB.user.create({
      data: user
    })
  }

  // Ù†Ù‚Ù„ Ø§Ù„Ø´Ø±ÙƒØ§Øª
  const companies = await sqliteDB.company.findMany()
  console.log(`ğŸ“¤ Ù†Ù‚Ù„ ${companies.length} Ø´Ø±ÙƒØ©...`)

  for (const company of companies) {
    await postgresDB.company.create({
      data: company
    })
  }

  // Ù†Ù‚Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
  const notifications = await sqliteDB.notification.findMany()
  console.log(`ğŸ“¤ Ù†Ù‚Ù„ ${notifications.length} Ø¥Ø´Ø¹Ø§Ø±...`)

  for (const notification of notifications) {
    await postgresDB.notification.create({
      data: notification
    })
  }

  console.log('âœ… ØªÙ… Ù†Ù‚Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­!')
}

migrate()
```

#### 2.4 Connection Pooling
```typescript
// src/modules/database/connection.ts
import { PrismaClient } from '@prisma/client'

export const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  },
  // Connection Pool Settings
  // ÙÙŠ DATABASE_URL ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ©:
  // ?connection_limit=20&pool_timeout=30
})

// Ø¥Ø¶Ø§ÙØ© Connection Pool Monitor
setInterval(async () => {
  const metrics = await prisma.$metrics.json()
  console.log('ğŸ“Š Database Pool Metrics:', {
    activeConnections: metrics.counters.find(c => c.key === 'prisma_client_queries_active')?.value || 0,
    totalQueries: metrics.counters.find(c => c.key === 'prisma_client_queries_total')?.value || 0
  })
}, 60000) // ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 3-5 Ø£ÙŠØ§Ù…
**Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:** ğŸ”´ Ø­Ø±Ø¬Ø©

---

### Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 3: Ø¥Ø¶Ø§ÙØ© Redis

#### 3.1 Ø¥Ø¹Ø¯Ø§Ø¯ Redis
```typescript
// src/modules/cache/redis-client.ts
import { createClient, RedisClientType } from 'redis'
import { logger } from '../../logger'

class RedisManager {
  private static instance: RedisManager
  private client: RedisClientType
  private isConnected = false

  private constructor() {
    this.client = createClient({
      url: process.env.REDIS_URL || 'redis://localhost:6379',
      socket: {
        reconnectStrategy: (retries) => {
          if (retries > 10) {
            logger.error('âŒ Redis: ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª')
            return new Error('Max retries exceeded')
          }
          return retries * 100
        }
      }
    })

    this.client.on('error', (err) => {
      logger.error('âŒ Redis Error:', err)
    })

    this.client.on('connect', () => {
      logger.info('âœ… Redis: Ù…ØªØµÙ„')
      this.isConnected = true
    })

    this.client.on('disconnect', () => {
      logger.warn('âš ï¸ Redis: Ø§Ù†Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„')
      this.isConnected = false
    })
  }

  static getInstance(): RedisManager {
    if (!RedisManager.instance) {
      RedisManager.instance = new RedisManager()
    }
    return RedisManager.instance
  }

  async connect(): Promise<void> {
    if (!this.isConnected) {
      await this.client.connect()
    }
  }

  getClient(): RedisClientType {
    return this.client
  }

  async disconnect(): Promise<void> {
    if (this.isConnected) {
      await this.client.quit()
    }
  }
}

export const redisManager = RedisManager.getInstance()
export const redis = redisManager.getClient()
```

#### 3.2 Cache Service
```typescript
import { logger } from '../../logger'
// src/modules/cache/cache-service.ts
import { redis } from './redis-client'

interface CacheOptions {
  ttl?: number // Time to live in seconds
  prefix?: string
}

export class CacheService {
  private defaultTTL = 3600 // Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©

  async get<T>(key: string, options?: CacheOptions): Promise<T | null> {
    try {
      const fullKey = this.buildKey(key, options?.prefix)
      const value = await redis.get(fullKey)

      if (!value)
        return null

      return JSON.parse(value) as T
    }
    catch (error) {
      logger.error('âŒ Cache Get Error:', error)
      return null
    }
  }

  async set<T>(key: string, value: T, options?: CacheOptions): Promise<void> {
    try {
      const fullKey = this.buildKey(key, options?.prefix)
      const ttl = options?.ttl || this.defaultTTL

      await redis.setEx(fullKey, ttl, JSON.stringify(value))
    }
    catch (error) {
      logger.error('âŒ Cache Set Error:', error)
    }
  }

  async delete(key: string, options?: CacheOptions): Promise<void> {
    try {
      const fullKey = this.buildKey(key, options?.prefix)
      await redis.del(fullKey)
    }
    catch (error) {
      logger.error('âŒ Cache Delete Error:', error)
    }
  }

  async deletePattern(pattern: string): Promise<void> {
    try {
      const keys = await redis.keys(pattern)
      if (keys.length > 0) {
        await redis.del(keys)
      }
    }
    catch (error) {
      logger.error('âŒ Cache Delete Pattern Error:', error)
    }
  }

  async exists(key: string, options?: CacheOptions): Promise<boolean> {
    try {
      const fullKey = this.buildKey(key, options?.prefix)
      return await redis.exists(fullKey) === 1
    }
    catch (error) {
      logger.error('âŒ Cache Exists Error:', error)
      return false
    }
  }

  async increment(key: string, options?: CacheOptions): Promise<number> {
    try {
      const fullKey = this.buildKey(key, options?.prefix)
      return await redis.incr(fullKey)
    }
    catch (error) {
      logger.error('âŒ Cache Increment Error:', error)
      return 0
    }
  }

  private buildKey(key: string, prefix?: string): string {
    return prefix ? `${prefix}:${key}` : key
  }
}

export const cacheService = new CacheService()
```

#### 3.3 ØªØ·Ø¨ÙŠÙ‚ Cache ÙÙŠ Ø§Ù„ÙƒÙˆØ¯
```typescript
// Ù…Ø«Ø§Ù„: ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
// src/modules/database/repositories/user-repository.ts
import { cacheService } from '../../cache/cache-service'

export class UserRepository {
  async findById(id: number) {
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø­ØµÙˆÙ„ Ù…Ù† Cache Ø£ÙˆÙ„Ø§Ù‹
    const cached = await cacheService.get<User>(`user:${id}`, {
      prefix: 'users'
    })

    if (cached) {
      logger.debug(`âœ… Cache Hit: user:${id}`)
      return cached
    }

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ ÙÙŠ CacheØŒ Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const user = await prisma.user.findUnique({ where: { id } })

    if (user) {
      // Ø­ÙØ¸ ÙÙŠ Cache
      await cacheService.set(`user:${id}`, user, {
        prefix: 'users',
        ttl: 1800 // 30 Ø¯Ù‚ÙŠÙ‚Ø©
      })
    }

    return user
  }

  async update(id: number, data: any) {
    const user = await prisma.user.update({
      where: { id },
      data
    })

    // ØªØ­Ø¯ÙŠØ« Cache
    await cacheService.set(`user:${id}`, user, {
      prefix: 'users',
      ttl: 1800
    })

    return user
  }

  async delete(id: number) {
    await prisma.user.delete({ where: { id } })

    // Ø­Ø°Ù Ù…Ù† Cache
    await cacheService.delete(`user:${id}`, { prefix: 'users' })
  }
}
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 3-4 Ø£ÙŠØ§Ù…
**Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:** ğŸ”´ Ø­Ø±Ø¬Ø©

---

### Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 4: Security Headers Ùˆ IP Management

#### 4.1 Ø¥Ø¶Ø§ÙØ© Security Headers
```typescript
// src/server/middlewares/security-headers.ts
import { Hono } from 'hono'
import { secureHeaders } from 'hono/secure-headers'

export function setupSecurityHeaders(app: Hono) {
  app.use('*', secureHeaders({
    contentSecurityPolicy: {
      defaultSrc: ['\'self\''],
      scriptSrc: ['\'self\'', '\'unsafe-inline\''],
      styleSrc: ['\'self\'', '\'unsafe-inline\''],
      imgSrc: ['\'self\'', 'data:', 'https:'],
      connectSrc: ['\'self\''],
      fontSrc: ['\'self\''],
      objectSrc: ['\'none\''],
      mediaSrc: ['\'self\''],
      frameSrc: ['\'none\'']
    },
    crossOriginEmbedderPolicy: false,
    crossOriginOpenerPolicy: { policy: 'same-origin' },
    crossOriginResourcePolicy: { policy: 'same-origin' },
    originAgentCluster: '?1',
    referrerPolicy: 'no-referrer',
    strictTransportSecurity: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true
    },
    xContentTypeOptions: 'nosniff',
    xDnsPrefetchControl: { allow: false },
    xDownloadOptions: 'noopen',
    xFrameOptions: 'DENY',
    xPermittedCrossDomainPolicies: 'none',
    xXssProtection: '1; mode=block'
  }))
}
```

#### 4.2 IP Whitelist/Blacklist System
```typescript
// Middleware
// src/server/middlewares/ip-filter.ts
import { Context, Next } from 'hono'

import { ipManager } from '../../modules/security/ip-manager'
// src/modules/security/ip-manager.ts
import { redis } from '../cache/redis-client'

export class IPManager {
  private whitelistKey = 'security:ip:whitelist'
  private blacklistKey = 'security:ip:blacklist'

  // Whitelist
  async addToWhitelist(ip: string, reason?: string): Promise<void> {
    await redis.hSet(this.whitelistKey, ip, JSON.stringify({
      addedAt: new Date().toISOString(),
      reason
    }))
  }

  async removeFromWhitelist(ip: string): Promise<void> {
    await redis.hDel(this.whitelistKey, ip)
  }

  async isWhitelisted(ip: string): Promise<boolean> {
    return await redis.hExists(this.whitelistKey, ip)
  }

  async getWhitelist(): Promise<Map<string, any>> {
    const data = await redis.hGetAll(this.whitelistKey)
    const result = new Map()

    for (const [ip, value] of Object.entries(data)) {
      result.set(ip, JSON.parse(value))
    }

    return result
  }

  // Blacklist
  async addToBlacklist(ip: string, reason?: string): Promise<void> {
    await redis.hSet(this.blacklistKey, ip, JSON.stringify({
      addedAt: new Date().toISOString(),
      reason
    }))
  }

  async removeFromBlacklist(ip: string): Promise<void> {
    await redis.hDel(this.blacklistKey, ip)
  }

  async isBlacklisted(ip: string): Promise<boolean> {
    return await redis.hExists(this.blacklistKey, ip)
  }

  async getBlacklist(): Promise<Map<string, any>> {
    const data = await redis.hGetAll(this.blacklistKey)
    const result = new Map()

    for (const [ip, value] of Object.entries(data)) {
      result.set(ip, JSON.parse(value))
    }

    return result
  }

  // Check
  async isAllowed(ip: string): Promise<{ allowed: boolean, reason?: string }> {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ BlacklistØŒ Ø±ÙØ¶
    if (await this.isBlacklisted(ip)) {
      const data = await redis.hGet(this.blacklistKey, ip)
      return {
        allowed: false,
        reason: data ? JSON.parse(data).reason : 'IP is blacklisted'
      }
    }

    // Ø¥Ø°Ø§ ÙƒØ§Ù† Whitelist ÙØ¹Ù‘Ø§Ù„ ÙˆIP Ù„ÙŠØ³ ÙÙŠÙ‡ØŒ Ø±ÙØ¶
    const whitelistSize = await redis.hLen(this.whitelistKey)
    if (whitelistSize > 0 && !(await this.isWhitelisted(ip))) {
      return {
        allowed: false,
        reason: 'IP is not whitelisted'
      }
    }

    return { allowed: true }
  }
}

export const ipManager = new IPManager()

export async function ipFilterMiddleware(c: Context, next: Next) {
  const ip = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown'

  const { allowed, reason } = await ipManager.isAllowed(ip)

  if (!allowed) {
    return c.json({
      error: 'Access Denied',
      reason
    }, 403)
  }

  return next()
}
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 2-3 Ø£ÙŠØ§Ù…
**Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:** ğŸŸ  Ø¹Ø§Ù„ÙŠØ©

---

## ğŸŸ¡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¬ÙˆØ¯Ø© (4 Ø£Ø³Ø§Ø¨ÙŠØ¹)

### Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 5-6: ÙƒØªØ§Ø¨Ø© Unit Tests

#### Unit Tests Structure
```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â”‚   â”œâ”€â”€ cache-service.test.ts
â”‚   â”‚   â”‚   â””â”€â”€ redis-client.test.ts
â”‚   â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”‚   â”œâ”€â”€ encryption.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ session-manager.test.ts
â”‚   â”‚   â”‚   â””â”€â”€ ip-manager.test.ts
â”‚   â”‚   â”œâ”€â”€ notifications/
â”‚   â”‚   â”‚   â”œâ”€â”€ notification-service.test.ts
â”‚   â”‚   â”‚   â””â”€â”€ template-service.test.ts
â”‚   â”‚   â””â”€â”€ database/
â”‚   â”‚       â””â”€â”€ repositories/
â”‚   â”‚           â”œâ”€â”€ user-repository.test.ts
â”‚   â”‚           â””â”€â”€ company-repository.test.ts
â”‚   â””â”€â”€ bot/
â”‚       â”œâ”€â”€ features/
â”‚       â”‚   â”œâ”€â”€ admin.test.ts
â”‚       â”‚   â””â”€â”€ notifications.test.ts
â”‚       â””â”€â”€ middlewares/
â”‚           â”œâ”€â”€ rate-limiter.test.ts
â”‚           â””â”€â”€ session.test.ts
```

#### Ù…Ø«Ø§Ù„: Cache Service Tests
```typescript
// tests/unit/modules/cache/cache-service.test.ts
import { afterEach, beforeEach, describe, expect, it } from '@jest/globals'
import { CacheService } from '../../../../src/modules/cache/cache-service'
import { redis } from '../../../../src/modules/cache/redis-client'

describe('CacheService', () => {
  let cacheService: CacheService

  beforeEach(async () => {
    cacheService = new CacheService()
    await redis.connect()
  })

  afterEach(async () => {
    await redis.flushAll()
  })

  describe('set and get', () => {
    it('should store and retrieve string value', async () => {
      await cacheService.set('test-key', 'test-value')
      const value = await cacheService.get<string>('test-key')
      expect(value).toBe('test-value')
    })

    it('should store and retrieve object value', async () => {
      const testObject = { name: 'Test', age: 25 }
      await cacheService.set('test-object', testObject)
      const value = await cacheService.get<typeof testObject>('test-object')
      expect(value).toEqual(testObject)
    })

    it('should return null for non-existent key', async () => {
      const value = await cacheService.get('non-existent')
      expect(value).toBeNull()
    })

    it('should respect TTL', async () => {
      await cacheService.set('ttl-test', 'value', { ttl: 1 })
      let value = await cacheService.get('ttl-test')
      expect(value).toBe('value')

      // Ø§Ù†ØªØ¸Ø§Ø± Ø«Ø§Ù†ÙŠØªÙŠÙ†
      await new Promise(resolve => setTimeout(resolve, 2000))

      value = await cacheService.get('ttl-test')
      expect(value).toBeNull()
    }, 3000)
  })

  describe('delete', () => {
    it('should delete existing key', async () => {
      await cacheService.set('delete-test', 'value')
      await cacheService.delete('delete-test')
      const value = await cacheService.get('delete-test')
      expect(value).toBeNull()
    })
  })

  describe('exists', () => {
    it('should return true for existing key', async () => {
      await cacheService.set('exists-test', 'value')
      const exists = await cacheService.exists('exists-test')
      expect(exists).toBe(true)
    })

    it('should return false for non-existent key', async () => {
      const exists = await cacheService.exists('non-existent')
      expect(exists).toBe(false)
    })
  })

  describe('increment', () => {
    it('should increment counter', async () => {
      const count1 = await cacheService.increment('counter')
      expect(count1).toBe(1)

      const count2 = await cacheService.increment('counter')
      expect(count2).toBe(2)
    })
  })
})
```

#### Ù…Ø«Ø§Ù„: Encryption Service Tests
```typescript
// tests/unit/modules/security/encryption.test.ts
import { describe, expect, it } from '@jest/globals'
import { EncryptionService } from '../../../../src/modules/security/encryption'

describe('EncryptionService', () => {
  describe('encrypt and decrypt', () => {
    it('should encrypt and decrypt string correctly', () => {
      const original = 'sensitive data'
      const encrypted = EncryptionService.encrypt(original)
      const decrypted = EncryptionService.decrypt(encrypted)

      expect(encrypted).not.toBe(original)
      expect(decrypted).toBe(original)
    })

    it('should produce different encrypted values for same input', () => {
      const original = 'test'
      const encrypted1 = EncryptionService.encrypt(original)
      const encrypted2 = EncryptionService.encrypt(original)

      expect(encrypted1).not.toBe(encrypted2)
      expect(EncryptionService.decrypt(encrypted1)).toBe(original)
      expect(EncryptionService.decrypt(encrypted2)).toBe(original)
    })

    it('should handle empty string', () => {
      const encrypted = EncryptionService.encrypt('')
      const decrypted = EncryptionService.decrypt(encrypted)
      expect(decrypted).toBe('')
    })

    it('should handle unicode characters', () => {
      const original = 'Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ! ä½ å¥½ ğŸ‰'
      const encrypted = EncryptionService.encrypt(original)
      const decrypted = EncryptionService.decrypt(encrypted)
      expect(decrypted).toBe(original)
    })
  })
})
```

**Ø§Ù„Ù‡Ø¯Ù:** 80%+ Code Coverage
**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 2 Ø£Ø³Ø¨ÙˆØ¹

---

### Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 7: Integration Tests

```typescript
// tests/integration/bot/features/admin.test.ts
import { afterAll, beforeAll, describe, expect, it } from '@jest/globals'
import { PrismaClient } from '@prisma/client'
import { Bot } from 'grammy'
import { createBot } from '../../../../src/bot'

describe('Admin Feature Integration', () => {
  let bot: Bot
  let prisma: PrismaClient
  let testUserId: number

  beforeAll(async () => {
    // Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø®ØªØ¨Ø§Ø±
    prisma = new PrismaClient({
      datasources: {
        db: {
          url: process.env.TEST_DATABASE_URL
        }
      }
    })

    // Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø®ØªØ¨Ø§Ø±
    const user = await prisma.user.create({
      data: {
        telegramId: BigInt(123456789),
        role: 'ADMIN',
        isActive: true
      }
    })
    testUserId = user.id

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª
    bot = await createBot()
  })

  afterAll(async () => {
    // ØªÙ†Ø¸ÙŠÙ
    await prisma.user.delete({ where: { id: testUserId } })
    await prisma.$disconnect()
  })

  it('should allow admin to access admin panel', async () => {
    // Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªÙƒØ§Ù…Ù„
    // ...
  })
})
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 1 Ø£Ø³Ø¨ÙˆØ¹

---

### Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 8: CI/CD Pipeline

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run prisma:generate

      - name: Run migrations
        run: npm run prisma:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

      - name: Run linter
        run: npm run lint

      - name: Run type check
        run: npm run typecheck

      - name: Run tests
        run: npm run test:coverage
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json

      - name: Build
        run: npm run build

  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run security audit
        run: npm audit --audit-level=moderate

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  deploy:
    needs: [test, security]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Deploy to production
        run: |
          # Ù†Ø´Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±
          echo "Deploying to production..."
```

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:** 3-4 Ø£ÙŠØ§Ù…

---

## ğŸ“Š Checklists Ù„Ù„ØªØ­Ù‚Ù‚

### âœ… Checklist Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ (Ø§Ù„Ø£Ù…Ø§Ù† ÙˆØ§Ù„Ø£Ø³Ø§Ø³ÙŠØ§Øª)

- [ ] Rate Limiting Ù…Ø·Ø¨Ù‚ ÙˆÙŠØ¹Ù…Ù„
- [ ] Data Encryption Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø©
- [ ] Session Management Ù†Ø´Ø·
- [ ] PostgreSQL ÙŠØ¹Ù…Ù„ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† SQLite
- [ ] Connection Pooling Ù…Ø­Ø³Ù‘Ù†
- [ ] Redis Ù…ØªØµÙ„ ÙˆÙŠØ¹Ù…Ù„
- [ ] Cache Service ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
- [ ] Security Headers Ù…Ø¶Ø§ÙØ©
- [ ] IP Management System ÙŠØ¹Ù…Ù„
- [ ] Ø¬Ù…ÙŠØ¹ environment variables Ù…Ø­Ø¯Ù‘Ø«Ø©

### âœ… Checklist Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© (Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª)

- [ ] Unit Tests: 80%+ Coverage
- [ ] Integration Tests Ù…ÙˆØ¬ÙˆØ¯Ø©
- [ ] E2E Tests Ù…ÙˆØ¬ÙˆØ¯Ø©
- [ ] CI/CD Pipeline ÙŠØ¹Ù…Ù„
- [ ] Code Coverage Reports ØªØ¸Ù‡Ø±
- [ ] Ø¬Ù…ÙŠØ¹ Tests ØªÙ†Ø¬Ø­
- [ ] Security Audit ÙŠÙ…Ø±
- [ ] Performance Tests ØªÙ…Ø±

---

## ğŸ“ˆ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ©

| Ø§Ù„Ù…Ù‚ÙŠØ§Ø³ | Ø§Ù„Ø­Ø§Ù„ÙŠ | Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù |
|---------|--------|----------|
| Test Coverage | ~10% | 80%+ |
| Response Time | - | <200ms |
| Security Score | 78% | 95%+ |
| Uptime | - | 99.9%+ |
| Cache Hit Rate | 0% | 85%+ |

---

## ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„ØªÙ‚Ø¯ÙŠØ±ÙŠØ©

### Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„ØªØ­ØªÙŠØ© (Ø´Ù‡Ø±ÙŠØ§Ù‹):
- PostgreSQL (Managed): $15-30
- Redis (Managed): $10-20
- Server (VPS/Cloud): $20-50
- Monitoring Tools: $0-50
- **Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:** $45-150/Ø´Ù‡Ø±

### ÙˆÙ‚Øª Ø§Ù„ØªØ·ÙˆÙŠØ±:
- Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: 160 Ø³Ø§Ø¹Ø© (4 Ø£Ø³Ø§Ø¨ÙŠØ¹ Ã— 40 Ø³Ø§Ø¹Ø©)
- Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: 160 Ø³Ø§Ø¹Ø© (4 Ø£Ø³Ø§Ø¨ÙŠØ¹ Ã— 40 Ø³Ø§Ø¹Ø©)

---

**Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ø­Ø³Ø¨ Ø£ÙˆÙ„ÙˆÙŠØ§ØªÙƒ!** ğŸš€

Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ±ÙŠØ¯ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø¬Ø²Ø¡ Ù…Ø¹ÙŠÙ†ØŒ Ø£Ùˆ ØªØ­ØªØ§Ø¬ ØªÙØ§ØµÙŠÙ„ Ø£ÙƒØ«Ø± Ø¹Ù† Ø£ÙŠ Ù…Ø±Ø­Ù„Ø©ØŒ Ø£Ø®Ø¨Ø±Ù†ÙŠ!
